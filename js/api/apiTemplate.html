<h2>API</h2>

<h4 id="extend">Nex.View.extend()</h4>

<p>Create a view by extending the base view.</p>

<pre class="prettyprint"><code>&lt;!-- myTemplate.html --&gt;
&lt;div&gt;Hello \{{model.name}}!&lt;/div&gt;
&lt;input type="text" placeholder="enter your name"&gt;
&lt;div id="todo-widget"&gt;&lt;/div&gt;</code></pre>

<pre class="prettyprint"><code>var MyView = Nex.View.extend({
  // The view's HTML template
  template: Handlebars.compile(myTemplate),

  // The model gets passed to the template
  model: { name: 'Nex' },

  // The layout contains your site's header, footer, etc.
  layout: LayoutView,

  // Event handlers
  on: {
    // Change the view to display your name
    'keypress input': function(event) {
      this.model.name = event.target.value;
      this.render();
    }
  },

  // Components are other views that are automatically created and attached to this view
  components: {
    '#todo-widget': TodoView
  }
});</code></pre>

<p>Create an instance of your view, render it, and attach it to the document.</p>

<pre class="prettyprint"><code>document.querySelector('body').appendChild(new MyView().outerEl);</code></pre>

<h4 id="properties" class="spacer">View Properties</h4>

<p>The view will have these properties.</p>

<ul>
  <li><code>view.el</code> - the view's DOM element</li>
  <li><code>view.outerEl</code> - the <code>view</code>'s or <code>layout</code>'s outer most DOM element</li>
  <li><code class="pln">view.template()</code> - generates the view's HTML</li>
  <li><code>view.model</code> - the model that gets passed to the template</li>
  <li><code>view.layout</code> - the layout contains your site's layout (header, footer, etc.)</li>
  <li><code>view.contentPlaceholder</code> - the CSS selector to the content placeholder element (only for layout views)</li>
  <li><code>view.on</code> - event handlers</li>
  <li><code>view.components</code> - sub-views or widgets that are automatically created and attached to the view</li>
  <li><code>view.render()</code> - renders the view which populates <code>view.el</code> with the template HTML</li>
  <li><code>view.html(htmlString)</code> - replaces the contents of <code>view.el</code> with the HTML string</li>
  <li><code>view.initialize()</code> - a hook to add additional logic when creating an instance of the view</li>
  <li><code>view.remove()</code> - remove the view from the DOM</li>
  <li><code>view.tagName</code> - the type of DOM element</li>
  <li><code>view.id</code> - the ID of the view's DOM element</li>
  <li><code>view.className</code> - the class name(s) of the view's DOM element</li>
  <li><code>view.autoRender</code> - defaults to <code>true</code>, set to <code>false</code> to manually trigger the first render</li>
  <li><code>view.dispatchMockEvent(mockEvent)</code> - triggers a mock event for integration testing event handlers</li>
</ul>

<h4 id="el" class="spacer">el</h4>

<p>The view's DOM element. It exists as soon as you create an instance of the view. This alows you to render the view before it's attached to the document. Delegate events are attached to <code>view.el</code> so they don't need to be re-bound every time you render your view.</p>

<p>To access DOM elements within the view you should scope your selectors using <code>view.el.querySelector()</code> and <code>view.el.querySelectorAll()</code>. This allows you to access the view's elements before attaching the view to the document. This makes unit testing much easier. It also keeps the selectors scoped to your view so you don't accidentally select an element outside of your view.</p>

<h4 id="outerEl" class="spacer">outerEl</h4>

<p>The view's or <code>layout</code>'s outer most DOM element. If you specify a <code>layout</code> then <code>view.outerEl</code> will refer to the <code>layout.el</code>. When you attach a view to the DOM you should use <code>outerEl</code> in case it has a layout view. You should attach your view's to the document like this <code>document.querySelector('body').appendChild(new MyView().outerEl)</code>. Then if <code>MyView</code> has set <code>layout: LayoutView</code> it will be <code>LayoutView.el</code> that is attached to the DOM.</p>

<h4 id="template" class="spacer">template()</h4>

<p>The template generates your view's HTML. You can use your choice of templating engines. Typically you would compile your template and set it on the template property.</p>

<pre class="prettyprint"><code>var MyView = Nex.View.extend({
  template: Handlebars.compile('&lt;div&gt;Hello \{{model.name}}!&lt;/div&gt;'),

  model: {name: 'Nex'},

  // The default render method processes the template and attaches it to the view's DOM element
  render: function render() {
    this.html(this.template({model: this.model}));
    return this;
  }
});</code></pre>

<p>The compile step creates a function that takes in a model and returns an HTML string. The <code>render()</code> method passes the model to the compiled template then takes the resulting HTML and attaches it to <code>view.el</code>.</p>

<h4 id="model" class="spacer">model</h4>

<p>The model contains your view's data. It can be an object or a constructor function. For example, if your model is <code>{name: 'Nex'}</code> it will be passed straight to the template. If your model is a constructor function like <code>function MyModel() {this.name = 'Nex'; this.time = new Date();}</code> it will be called with <code>new view.model()</code> before being passed to the template. This allows for variables to be evaluated at render time. This is useful when you need access to a closure variable that changes often.</p>

<h4 id="layout" class="spacer">layout</h4>

<p>The <code>layout</code> is a constructor or instance of a special view that contains your site's header, footer, etc. The layout is like a .NET master page or Razor layout. This makes routing easy since you don't need an intermediate step to render the layout. Calling <code>render()</code> on the view will automatically call <code>render()</code> on the layout. The view is attached to the layout using the layout's <code>contentPlaceholder</code> selector. Once the views are done rendering <code>view.outerEl</code> will contain both the view and the layout. Here's an example view and layout view.</p>

<pre class="prettyprint"><code>var LayoutView = Nex.View.extend({
  template: Handlebars.compile('&lt;header&gt;Header&lt;/header&gt;&lt;div id="content"&gt;&lt;/div&gt;'),
  contentPlaceholder: '#content'
});

var MyView = Nex.View.extend({
  template: Handlebars.compile('MyView HTML'),
  layout: LayoutView
});

document.querySelector('body').appendChild(new MyView().outerEl);</code></pre>

The <code>body</code> HTML will be.
<pre class="prettyprint"><code>&lt;div&gt; &lt;!-- layoutView.el, homeView.outerEl --&gt;
  &lt;header&gt;Header&lt;/header&gt;
  &lt;div id="content"&gt;
    &lt;div&gt;MyView HTML&lt;/div&gt; &lt;!-- homeView.el --&gt;
  &lt;/div&gt;
&lt;/div&gt;</code></pre>

<h4 id="contentPlaceholder" class="spacer">contentPlaceholder</h4>

<p>If a view is going to be used as a <code>layout</code> it needs to have a content placeholder element in its HTML and set <code>view.contentPlaceholder</code>. This is the CSS selector of the content placeholder element in the HTML. When you call <code>render()</code> on the child view it will automatically call <code>render()</code> on the layout view and use the <code>layout.contentPlaceholder</code> to attach the child view to the layout.</p>

<p>Note: If a view has a <code>contentPlaceholder</code> it is considered a layout and will not be rendered when a new instance is constructed. Instead it will wait to be rendered until the child view is rendered.</p>

<h4 id="on" class="spacer">on</h4>

<p>Event handlers. These are delegate events. They are bound once to the view's root element so you don't have to bind events every time you call <code>render()</code>. Events are slightly different than jQuery delegate events since there aren't native ECMAScript delegate events. <code>event.target</code> and <code>event.currentTarget</code> are swapped from the way jQuery does it. jQuery got these backwards and the native events have them set correctly. Here is an example event and event handler.</p>

<pre class="prettyprint"><code>var MyView = Nex.View.extend({
  on: {
    'click span a': function(event) {
      this; // will reference your instance of `MyView`
      event.target; // will reference the DOM element the action took place on. This is `a` in this example.
      event.currentTarget; // will reference `this.el` which is the root element that all events are bound to.
    }
  }
});</code></pre>

<h4 id="components" class="spacer">components</h4>

<p>These are views or widgets that are automatically created and attached to the view. When an instance of the view is created it creates instances of the components and attaches them to their selectors.</p>

<pre class="prettyprint"><code>var Widget = Nex.View.extend({
  template: Handlebars.compile('I\'m a widget!')
});

var MyView = Nex.View.extend({
  template: Handlebars.compile('&lt;div&gt;Example component below.&lt;/div&gt;&lt;div id="widget1"&gt;&lt;/div&gt;'),
  components: {
    '#widget1': Widget
  }
});</code></pre>

An instance of <code>MyView</code> will have this HTML.
<pre class="prettyprint"><code>&lt;div&gt;Example component below.&lt;/div&gt;
&lt;div id="widget1"&gt;
  &lt;div&gt;I'm a widget!&lt;/div&gt;
&lt;/div&gt;</code></pre>

<p>The cool thing about components is if you re-render this view it doesn't have to re-render the components. This view already has references to the rendered components so it just attaches them again when the view finishes re-rendering. The same thing goes for re-rendering a layout view. Underneath it takes the <code>contentPlaceholder</code> and turns it into a component. When you re-render the layout it just attaches this view again using the <code>contentPlaceholder</code>.</p>

<h4 id="render" class="spacer">render()</h4>

<p>Render populates the contents of <code>view.el</code> with the template HTML. This is called when you create a new instance of a view. When your model changes you call <code>render()</code> to update the DOM. Every view has a default <code>render()</code> method that looks like this.</p>

<pre class="prettyprint"><code>function render() {
  this.html(this.template({model: this.model}));
  return this;
}</code></pre>

<p>You can override this to add your own functionality. <code>render()</code> will also handle rendering the <code>layout</code> if it has one. Overriding <code>view.render()</code> will still render the <code>layout</code> but will let you change how the current view is rendered.</p>

<h4 id="html" class="spacer">html(htmlString)</h4>

<p>Converts the HTML string to DOM elements and replaces the contents of <code>view.el</code>. This is like setting <code>view.el.innerHTML</code> but works better in IE8. This is used by the default <code>render()</code> method.</p>

<h4 id="initialize" class="spacer">initialize</h4>

<p>You can use the initialize method to add custom logic when creating a new instance of your view. In this example the <code>view.model.name</code> is passed in as an argument in the constructor.</p>

<pre class="prettyprint"><code>var MyView = Nex.View.extend({
  template: Handlebars.compile('&lt;div&gt;Hello \{{model.name}}!&lt;/div&gt;'),
  model: {},
  initialize: function(name) {
    this.model.name = name;
  }
});

var myView = new MyView("Nex");

document.querySelector('body').appendChild(myView.outerEl); // Will display "Hello Nex!"</code></pre>

<p>The <code>initialize()</code> method is the last step before the instance is returned so everything else is set up at this point.</p>

<h4 id="remove" class="spacer">remove()</h4>

<p>Removes <code>view.el</code> from the DOM.</p>

<h4 id="tagName" class="spacer">tagName</h4>

<p>The type of DOM element - div, span, section, header, footer, etc. It defaults to a <code>div</code>.</p>

<h4 id="id" class="spacer">id</h4>

<p>The ID of the view's DOM element.</p>

<h4 id="className" class="spacer">className</h4>

<p>The class name(s) of the view's DOM element.</p>

<h4 id="autoRender" class="spacer">autoRender</h4>

<p>Defaults to <code>true</code>, set to <code>false</code> to manually trigger the first render.</p>

<h4 id="dispatchMockEvent" class="spacer">dispatchMockEvent(mockEvent)</h4>

<p>Triggers a mock event for integration testing event handlers. If you just want to unit test your event handlers you can call the functions directly with a mock object. The benefit of dispatching an event is that it might trigger multiple event handlers.</p>

<p>The <code>mockEvent</code> must contain a <code>type</code> and <code>target</code>. The <code>type</code> is a click, keypress, etc. The <code>target</code> is the DOM element you're performing the action on. You can add any other properties your event handlers expect. Here's an example test that verifies that entering a new item and hitting enter saves the item to the view's model.</p>

<pre class="prettyprint"><code>// Arrange
var myView = new MyView();

// Act
var textInput = myView.el.querySelector('input.new');
textInput.value = 'my first item!';
myView.dispatchMockEvent({
  type: 'keypress',
  target: textInput,
  keyCode: 13
});

// Assert
expect(myView.model.items.length).toEqual(1);
expect(myView.model.items[0].title).toEqual('my first item!');</code></pre>
