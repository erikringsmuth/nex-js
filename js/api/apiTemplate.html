<h2>API</h2>

<h4 id="extend">Nex.View.extend()</h4>

<p>Create a view by extending the base view.</p>

<pre>var MyView = Nex.View.extend({
  template: Handlebars.compile('&lt;div&gt;Hello \{{model.name}}!&lt;/div&gt;'),
  model: {name: 'Erik Ringsmuth'}
});</pre>

<p>Create an instance of your view, render it, and attach it to the document.</p>

<pre>document.querySelector('body').appendChild(new MyView().render().outerEl);</pre>

<h4 id="properties">View Properties</h4>

<p>The view will have these properties.</p>

<ul>
  <li><code>view.render()</code> - renders the view which populates <code>view.el</code></li>
  <li><code>view.el</code> - the view's DOM element</li>
  <li><code>view.model</code> - the model that gets passed to the template</li>
  <li><code>view.template()</code> - generates the view's HTML</li>
  <li><code>view.events</code> - delegate events that are bound once to the root object so subsequent calls to <code>view.render()</code> don't need to re-bind events</li>
  <li><code>view.layoutView</code> - the layout view contains your site's layout (header, footer, etc.)</li>
  <li><code>view.outerEl</code> - the <code>view</code>'s or <code>layoutView</code>'s outer most DOM element</li>
  <li><code>view.contentPlaceholderId</code> - the ID of a layout view's content placeholder element</li>
  <li><code>view.remove()</code> - remove the view from the DOM</li>
  <li><code>view.initialize()</code> - a hook to add additional logic when creating an instance of the view</li>
  <li><code>view.tagName</code> - the type of DOM element</li>
  <li><code>view.id</code> - the ID of the view's DOM element</li>
  <li><code>view.className</code> - the class name(s) of the view's DOM element</li>
</ul>

<h4 id="render">render()</h4>

<p>If you don't override <code>view.render()</code> it will call <code>view.template({model: view.model})</code> and set the result to <code>view.el.innerHTML</code>. You can override this to add your own functionality. <code>render()</code> will also handle rendering the <code>layoutView</code> if it has one. Overriding <code>view.render()</code> will still render the <code>layoutView</code> but will let you change how the current view is rendered. The default implementation of <code>view.render()</code> is close to this.</p>

<pre>function render() {
  this.el.innerHTML = this.template({model: this.model});
  return this;
}</pre>

<h4 id="el">el</h4>

<p>The view's DOM element. It exists as soon as you create an instance of the view before it's ever attached to the document. To access DOM elements within the view you should scope your selectors using <code>view.el.querySelector()</code> and <code>view.el.querySelectorAll()</code>. This allows you to access the view's elements before attaching the view to the document. This makes unit testing much easier. It also keeps the selectors scoped to your view so you don't accidentally select an element outside of your view.</p>

<h4 id="model">model</h4>

<p>The model can be an object or a constructor function. For example, if your model is <code>{name: 'Erik Ringsmuth'}</code> it will be passed straight to the template. If your model is a constructor function like <code>function() {this.name = 'Erik Ringsmuth'; this.time = new Date();}</code> it will be called with <code>new view.model()</code> before being passed to the template. This allows for variables to be evaluated at render time. This is useful when you need access to a closure variable that changes often.</p>

<h4 id="template">template()</h4>

<p>The template generates your view's HTML. You can use your choice of templating engines. Typically you would compile your template and set it on the template property.</p>

<pre>var MyView = Nex.View.extend({
  template: Handlebars.compile('&lt;div&gt;Hello \{{model.name}}!&lt;/div&gt;'),
  model: {name: 'Erik Ringsmuth'},
  render: function render() {
    this.el.innerHTML = this.template({model: this.model});
    return this;
  }
});</pre>

<p>The compile step creates a function that takes in a model and returns an HTML string. The <code>render()</code> method passes the model to the compiled template then takes the resulting HTML and attaches it to <code>view.el</code>. The <code>render()</code> method passes the view's model to the template and you can access the model in the template using the <code>model</code> variable.</p>

<h4 id="events">events</h4>

<p>Delegate events are bound once to the view's root element so you don't have to bind events every time you call <code>render()</code>. Events work slightly differently than jQuery delegate events since there aren't native ECMAScript delegate events. <code>event.target</code> and <code>event.currentTarget</code> are swapped from the way jQuery does it. From what I can tell jQuery got these backwards and the native events have them set correctly. Here is an example event and event handler.</p>

<pre>var MyView = Nex.View.extend({
  events: { 'click span a': 'anchorEventHandler' },
  anchorEventHandler : function(event) {
    this; // will reference your instance of `MyView`
    event.target; // will reference the DOM element the action took place on. This is `a` in this example.
    event.currentTarget; // will reference `this.el` which is the root element that all events are bound to.
  }
});</pre>

<h4 id="layoutView">layoutView</h4>

<p>The view's <code>layoutView</code> contains your site's general layout like the header, footer, etc. It's like a .NET master page. This makes it easy to use a javascript router to load your views rendering your view will also render the layout. Calling <code>render()</code> on your view will automatically call render() on the layout view and attach the your view to the <code>layoutView</code> using the <code>layoutView.contentPlaceholderId</code> to get the content placeholder element. The <code>layoutView</code>'s render method will be called even if you override the child view's render method. Here's an example view and layout view.</p>

<pre>var LayoutView = Nex.View.extend({
  template: Handlebars.compile('&lt;header&gt;Header&lt;/header&gt;&lt;div id="content"&gt;&lt;/div&gt;'),
  contentPlaceholderId: 'content'
});

var MyView = Nex.View.extend({
  template: Handlebars.compile('MyView HTML'),
  layoutView: new LayoutView()
});

document.querySelector('body').appendChild(new MyView().render().outerEl);

// The body's innerHTML will be:
// &lt;header&gt;Header&lt;/header&gt;&lt;div id="content"&gt;&lt;div&gt;MyView HTML&lt;/div&gt;&lt;/div&gt;</pre>

<h4 id="outerEl">outerEl</h4>

<p>The view's or <code>layoutView</code>'s outer most DOM element. If you specify a <code>layoutView</code> then <code>view.outerEl</code> will refer to the <code>layoutView.el</code>. When you attach a view to the DOM you should use the <code>outerEl</code> in case it has a layout view. You should attach your view's to the document like this <code>document.querySelector('body').appendChild(new MyView().render().outerEl)</code>. Then if <code>MyView</code> has set <code>layoutView: new LayoutView()</code> it will be <code>LayoutView.el</code> that is attached to the DOM.</p>

<h4 id="contentPlaceholderId">contentPlaceholderId</h4>

<p>If a view is going to be used as a <code>layoutView</code> it needs to have a content-placeholder element in its HTML and set <code>view.contentPlaceholderId</code>. This is the ID of the content-placeholder element in the HTML. When you call <code>render()</code> on the child view it will automatically call <code>render()</code> on the layout view and use the <code>layoutView.contentPlaceholderId</code> to attach the child view to the layout view.</p>

<h4 id="remove">remove()</h4>

<p>Removes <code>view.el</code> from the DOM.</p>

<h4 id="initialize">initialize</h4>

<p>You can use the initialize method to add custom logic when creating a new instance of your view. In this example the <code>view.model.name</code> is passed in as an argument in the constructor.</p>

<pre>var MyView = Nex.View.extend({
  initialize: function(name) {
    this.model.name = name;
  },
  template: Handlebars.compile('&lt;div&gt;Hello \{{model.name}}!&lt;/div&gt;'),
  model: {name: ''},
  render: function render() {
    this.el.innerHTML = this.template({model: this.model});.
    return this;
  }
});
var myView = new MyView("Erik Ringsmuth");
myView.render();
document.querySelector('body').appendChild(myView.outerEl); // Will display "Hello Erik Ringsmuth!"</pre>

<p>The <code>initialize()</code> method is the last step before the instance is returned so everything else is set up at this point.</p>

<h4 id="tagName">tagName</h4>

<p>The type of DOM element - div, span, section, header, footer, etc. It defaults to a <code>div</code>.</p>

<h4 id="id">id</h4>

<p>The ID of the view's DOM element.</p>

<h4 id="className">className</h4>

<p>The class name(s) of the view's DOM element.</p>
