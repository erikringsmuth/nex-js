<h2>API</h2>

<h4 id="extend">Example template</h4>

<p>This is your view's HTML. Choose any template engine! Handlebars is just an example.</p>

<pre class="prettyprint"><code>&lt;!-- myTemplate.html --&gt;
&lt;div&gt;Hello \{{model.name}}!&lt;/div&gt;

&lt;!-- on-eventtype attributes call the event handler and are scoped to this view --&gt;
&lt;input type="text" placeholder="Enter your name" on-keypress="updateNameOnEnter"&gt;

&lt;div id="todo-widget"&gt;
  &lt;!-- A Todo MVC widget will be attached here --&gt;
&lt;/div&gt;</code></pre>

<h4 id="extend" class="spacer">Nex.View.extend()</h4>

<p>Create a view by extending the base view.</p>

<pre class="prettyprint"><code>var MyView = Nex.View.extend({
  // The view's HTML template
  template: Handlebars.compile(myTemplate),

  // The model gets passed to the template
  model: { name: 'Nex' },

  // The layout contains your site's header, footer, etc.
  layout: LayoutView,

  // This event handler gets called when a keypress event is triggered on the input
  updateNameOnEnter: function(event) {
    this; // will reference the instance of `MyView`
    event.target; // will reference the DOM element the action took place on. This is the `input` in this example.
    if (event.keyCode === 13) {
      this.model.name = event.target.value;
      this.render();
    }
  },

  // Components are sub-views that are automatically created and attached to this view
  components: {
    '#todo-widget': TodoView
  }
});</code></pre>

<p>Create an instance of your view, render it, and attach it to the document.</p>

<pre class="prettyprint"><code>new MyView().attachTo('body');</code></pre>

<h4 id="properties" class="spacer">View Properties</h4>

<p>The view will have these properties.</p>

<ul>
  <li><code>view.el</code> - the view's DOM element</li>
  <li><code>view.outerEl</code> - the <code>view</code>'s or <code>layout</code>'s outer most DOM element</li>
  <li><code class="pln">view.template()</code> - generates the view's HTML</li>
  <li><code>view.model</code> - the model that gets passed to the template</li>
  <li><code>view.layout</code> - the layout contains your site's layout (header, footer, etc.)</li>
  <li><code>view.contentPlaceholder</code> - the CSS selector to the content placeholder element (only for layout views)</li>
  <li><code>view.components</code> - sub-views or widgets that are automatically created and attached to the view</li>
  <li><code>view.render()</code> - renders the view which populates <code>view.el</code> with the template HTML</li>
  <li><code>view.html(htmlString)</code> - replaces the contents of <code>view.el</code> with the HTML string</li>
  <li><code>view.attachTo(selector|element)</code> - attaches <code>view.outerEl</code> to the element</li>
  <li><code>view.initialize()</code> - a hook to add additional logic when creating an instance of the view</li>
  <li><code>view.remove()</code> - remove the view from the DOM</li>
  <li><code>view.tagName</code> - the type of DOM element</li>
  <li><code>view.id</code> - the ID of the view's DOM element</li>
  <li><code>view.className</code> - the class name(s) of the view's DOM element</li>
  <li><code>view.autoRender</code> - defaults to <code>true</code>, set to <code>false</code> to manually trigger the first render</li>
  <li><code>view.dispatchEvent(event)</code> - dispatches a delegate event to the correct event handler</li>
</ul>

<h4 id="el" class="spacer">el</h4>

<p>The view's DOM element. It exists as soon as you create an instance of the view. This alows you to render the view before it's attached to the document. Delegate events are attached to <code>view.el</code> so they don't need to be re-bound every time you render your view.</p>

<p>To access DOM elements within the view you should scope your selectors using <code>view.el.querySelector()</code> and <code>view.el.querySelectorAll()</code>. This allows you to access the view's elements before attaching the view to the document. This makes unit testing much easier. It also keeps the selectors scoped to your view so you don't accidentally select an element outside of your view.</p>

<h4 id="outerEl" class="spacer">outerEl</h4>

<p>The view's or <code>layout</code>'s outer most DOM element. If you specify a <code>layout</code> then <code>view.outerEl</code> will refer to the <code>layout.el</code>. When you attach a view to the DOM you should use <code>outerEl</code>. Calling <code>view.attachTo('body')</code> will attach <code>view.outerEl</code> to the body.</p>

<h4 id="template" class="spacer">template()</h4>

<p>The template generates your view's HTML. You can use your choice of templating engines. Typically you would compile your template and set it on the template property.</p>

<pre class="prettyprint"><code>var MyView = Nex.View.extend({
  template: Handlebars.compile('&lt;div&gt;Hello \{{model.name}}!&lt;/div&gt;'),

  model: {name: 'Nex'},

  // The default render method processes the template and attaches it to the view's DOM element
  render: function render() {
    this.html(this.template({model: this.model}));
    return this;
  }
});</code></pre>

<p>The compile step creates a function that takes in a model and returns an HTML string. The <code>render()</code> method passes the model to the compiled template then takes the resulting HTML and attaches it to <code>view.el</code>.</p>

<h4 id="model" class="spacer">model</h4>

<p>The model contains your view's data. It can be an object or a constructor function. For example, if your model is <code>{name: 'Nex'}</code> it will be passed straight to the template. If your model is a constructor function like <code>function MyModel() {this.name = 'Nex'; this.time = new Date();}</code> it will be called with <code>new view.model()</code> before being passed to the template. This allows for variables to be evaluated at render time. This is useful when you need access to a closure variable that changes often.</p>

<h4 id="layout" class="spacer">layout</h4>

<p>The <code>layout</code> is a constructor or instance of a special view that contains your site's header, footer, etc. The layout is like a .NET master page or Razor layout. This makes routing easy since you don't need an intermediate step to render the layout. Calling <code>render()</code> on the view will automatically call <code>render()</code> on the layout. The view is attached to the layout using the layout's <code>contentPlaceholder</code> selector. Once the views are done rendering <code>view.outerEl</code> will contain both the view and the layout. Here's an example view and layout view.</p>

<pre class="prettyprint"><code>var LayoutView = Nex.View.extend({
  template: Handlebars.compile('&lt;header&gt;Header&lt;/header&gt;&lt;div id="content"&gt;&lt;/div&gt;'),
  contentPlaceholder: '#content'
});

var MyView = Nex.View.extend({
  template: Handlebars.compile('MyView HTML'),
  layout: LayoutView
});

new MyView().attachTo('body');</code></pre>

The <code>body</code> HTML will be.
<pre class="prettyprint"><code>&lt;div&gt; &lt;!-- layoutView.el, homeView.outerEl --&gt;
  &lt;header&gt;Header&lt;/header&gt;
  &lt;div id="content"&gt;
    &lt;div&gt;MyView HTML&lt;/div&gt; &lt;!-- homeView.el --&gt;
  &lt;/div&gt;
&lt;/div&gt;</code></pre>

<h4 id="contentPlaceholder" class="spacer">contentPlaceholder</h4>

<p>If a view is going to be used as a <code>layout</code> it needs to have a content placeholder element in its HTML and set <code>view.contentPlaceholder</code>. This is the CSS selector of the content placeholder element in the HTML. When you call <code>render()</code> on the child view it will automatically call <code>render()</code> on the layout view and use the <code>layout.contentPlaceholder</code> to attach the child view to the layout.</p>

<p>Note: If a view has a <code>contentPlaceholder</code> it is considered a layout and will not be rendered when a new instance is constructed. Instead it will wait to be rendered until the child view is rendered.</p>

<h4 id="components" class="spacer">components</h4>

<p>These are views or widgets that are automatically created and attached to the view. When an instance of the view is created it creates instances of the components and attaches them to their selectors.</p>

<pre class="prettyprint"><code>var Widget = Nex.View.extend({
  template: Handlebars.compile('I\'m a widget!')
});

var MyView = Nex.View.extend({
  template: Handlebars.compile('&lt;div&gt;Example component below.&lt;/div&gt;&lt;div id="widget1"&gt;&lt;/div&gt;'),
  components: {
    '#widget1': Widget
  }
});</code></pre>

An instance of <code>MyView</code> will have this HTML.
<pre class="prettyprint"><code>&lt;div&gt;Example component below.&lt;/div&gt;
&lt;div id="widget1"&gt;
  &lt;div&gt;I'm a widget!&lt;/div&gt;
&lt;/div&gt;</code></pre>

<p>The cool thing about components is if you re-render this view it doesn't have to re-render the components. This view already has references to the rendered components so it just attaches them again when the view finishes re-rendering. The same thing goes for re-rendering a layout view. Underneath it takes the <code>contentPlaceholder</code> and turns it into a component. When you re-render the layout it just attaches this view again using the <code>contentPlaceholder</code>.</p>

<h4 id="render" class="spacer">render()</h4>

<p>Render populates the contents of <code>view.el</code> with the template HTML. This is called when you create a new instance of a view. When your model changes you call <code>render()</code> to update the DOM. Every view has a default <code>render()</code> method that looks like this.</p>

<pre class="prettyprint"><code>function render() {
  this.html(this.template({model: this.model}));
  return this;
}</code></pre>

<p>You can override this to add your own functionality. <code>render()</code> will also handle rendering the <code>layout</code> if it has one. Overriding <code>view.render()</code> will still render the <code>layout</code> but will let you change how the current view is rendered.</p>

<h4 id="html" class="spacer">html(htmlString)</h4>

<p>Converts the HTML string to DOM elements and replaces the contents of <code>view.el</code>. This is like setting <code>view.el.innerHTML</code> but works better in IE8. This is used by the default <code>render()</code> method.</p>

<h4 id="attachTo" class="spacer">attachTo(selector|element)</h4>

<p>Attaches <code>view.outerEl</code> to the element. This clears the contents of the element then appends the view.</p>

<h4 id="initialize" class="spacer">initialize</h4>

<p>You can use the initialize method to add custom logic when creating a new instance of your view. In this example the <code>view.model.name</code> is passed in as an argument in the constructor.</p>

<pre class="prettyprint"><code>var MyView = Nex.View.extend({
  template: Handlebars.compile('&lt;div&gt;Hello \{{model.name}}!&lt;/div&gt;'),
  model: {},
  initialize: function(name) {
    this.model.name = name;
  }
});

new MyView("Nex").attachTo('body'); // Will display "Hello Nex!"</code></pre>

<p>The <code>initialize()</code> method is the last step before the instance is returned so everything else is set up at this point.</p>

<h4 id="remove" class="spacer">remove()</h4>

<p>Removes <code>view.el</code> from the DOM.</p>

<h4 id="tagName" class="spacer">tagName</h4>

<p>The type of DOM element - div, span, section, header, footer, etc. It defaults to a <code>div</code>.</p>

<h4 id="id" class="spacer">id</h4>

<p>The ID of the view's DOM element.</p>

<h4 id="className" class="spacer">className</h4>

<p>The class name(s) of the view's DOM element.</p>

<h4 id="autoRender" class="spacer">autoRender</h4>

<p>Defaults to <code>true</code>, set to <code>false</code> to manually trigger the first render.</p>

<h4 id="dispatchMockEvent" class="spacer">dispatchEvent(event)</h4>

<p>Dispatches a delegate event to the correct event handler. You can also call this with a mock event for unit testing. Here's an example test.</p>

<pre class="prettyprint"><code>// Arrange
var myView = new MyView();

// Act
var input = myView.el.querySelector('input');
input.value = 'my first item!';
myView.dispatchEvent({
  type: 'keypress',
  target: input,
  keyCode: 13
});

// Assert
expect(myView.model.items.length).toEqual(1);
expect(myView.model.items[0].title).toEqual('my first item!');</code></pre>

<h4 id="events" class="spacer">Events</h4>

<p>Events are defined on an element using a hyphenated <code>on-eventtype</code> attribute.</p>

<pre class="prettyprint"><code>&lt;input type="text" on-keypress="updateNameOnEnter"&gt;</code></pre>

<p>This differs from regular JavaScript event handlers that are not hyphenated. This will call the global <code>window.updateNameOnEnter()</code>.</p>

<pre class="prettyprint"><code>&lt;input type="text" onkeypress="updateNameOnEnter()"&gt;</code></pre>

<p>Nex events are scoped to the current view. The <code>on-keypress="updateNameOnEnter"</code> attribute tells the view to call the <code>updateNameOnEnter(event)</code> event handler.</p>

<pre class="prettyprint"><code>var MyView = Nex.View.extend({
  template: Handlebars.compile(myTemplate),

  updateNameOnEnter: function(event) {
    this; // will reference the instance of `MyView`
    event.target; // will reference the DOM element the action took place on. This is the `input` in this example.

    // 13 is the enter key
    if (event.keyCode === 13) {
      this.model.name = event.target.value;
      this.render();
    }
  }
});</code></pre>

<p>Using attributes is declarative and easy to understand. They're even more efficient than regular delegate events because there's only one event listener per event type.</p>
