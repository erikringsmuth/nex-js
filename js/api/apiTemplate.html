<h2>API</h2>

<h4 id="extend">Nex.View.extend()</h4>

<p>Create a view by extending the base view.</p>

<pre class="prettyprint"><code>var MyView = Nex.View.extend({
  template: Handlebars.compile('&lt;div&gt;Hello \{{model.name}}!&lt;/div&gt;'),
  model: {name: 'Nex'}
});</code></pre>

<p>Create an instance of your view, render it, and attach it to the document.</p>

<pre class="prettyprint"><code>document.querySelector('body').appendChild(new MyView().render().outerEl);</code></pre>

<h4 id="properties" class="spacer">View Properties</h4>

<p>The view will have these properties.</p>

<ul>
  <li><code>view.render()</code> - renders the view which populates <code>view.el</code></li>
  <li><code>view.el</code> - the view's DOM element</li>
  <li><code>view.model</code> - the model that gets passed to the template</li>
  <li><code class="pln">view.template()</code> - generates the view's HTML</li>
  <li><code>view.events</code> - delegate events that are bound once to the root object so subsequent calls to <code>view.render()</code> don't need to re-bind events</li>
  <li><code>view.layoutView</code> - the layout view contains your site's layout (header, footer, etc.)</li>
  <li><code>view.outerEl</code> - the <code>view</code>'s or <code>layoutView</code>'s outer most DOM element</li>
  <li><code>view.contentPlaceholderId</code> - the ID of a layout view's content placeholder element</li>
  <li><code>view.remove()</code> - remove the view from the DOM</li>
  <li><code>view.initialize()</code> - a hook to add additional logic when creating an instance of the view</li>
  <li><code>view.tagName</code> - the type of DOM element</li>
  <li><code>view.id</code> - the ID of the view's DOM element</li>
  <li><code>view.className</code> - the class name(s) of the view's DOM element</li>
  <li><code>view.dispatchMockEvent(mockEvent)</code> - triggers a mock event for integration testing event handlers</li>
</ul>

<h4 id="render" class="spacer">render()</h4>

<p>Every view has a default <code>render()</code> method that looks like this.</p>

<pre class="prettyprint"><code>function render() {
  this.el.innerHTML = this.template({model: this.model});
  return this;
}</code></pre>

<p>You can override this to add your own functionality. <code>render()</code> will also handle rendering the <code>layoutView</code> if it has one. Overriding <code>view.render()</code> will still render the <code>layoutView</code> but will let you change how the current view is rendered.</p>

<h4 id="el" class="spacer">el</h4>

<p>The view's DOM element. It exists as soon as you create an instance of the view. This alows you to render the view before it's attached to the document. Delegate events are attached to <code>view.el</code> so they don't need to be re-bound every time you render your view.</p>

<p>To access DOM elements within the view you should scope your selectors using <code>view.el.querySelector()</code> and <code>view.el.querySelectorAll()</code>. This allows you to access the view's elements before attaching the view to the document. This makes unit testing much easier. It also keeps the selectors scoped to your view so you don't accidentally select an element outside of your view.</p>

<h4 id="model" class="spacer">model</h4>

<p>The model contains your view's data. It can be an object or a constructor function. For example, if your model is <code>{name: 'Nex'}</code> it will be passed straight to the template. If your model is a constructor function like <code>function MyModel() {this.name = 'Nex'; this.time = new Date();}</code> it will be called with <code>new view.model()</code> before being passed to the template. This allows for variables to be evaluated at render time. This is useful when you need access to a closure variable that changes often.</p>

<h4 id="template" class="spacer">template()</h4>

<p>The template generates your view's HTML. You can use your choice of templating engines. Typically you would compile your template and set it on the template property.</p>

<pre class="prettyprint"><code>var MyView = Nex.View.extend({
  template: Handlebars.compile('&lt;div&gt;Hello \{{model.name}}!&lt;/div&gt;'),
  model: {name: 'Nex'},
  render: function render() {
    this.el.innerHTML = this.template({model: this.model});
    return this;
  }
});</code></pre>

<p>The compile step creates a function that takes in a model and returns an HTML string. The <code>render()</code> method passes the model to the compiled template then takes the resulting HTML and attaches it to <code>view.el</code>.</p>

<h4 id="events" class="spacer">events</h4>

<p>Delegate events are bound once to the view's root element so you don't have to bind events every time you call <code>render()</code>. Events work slightly differently than jQuery delegate events since there aren't native ECMAScript delegate events. <code>event.target</code> and <code>event.currentTarget</code> are swapped from the way jQuery does it. From what I can tell jQuery got these backwards and the native events have them set correctly. Here is an example event and event handler.</p>

<pre class="prettyprint"><code>var MyView = Nex.View.extend({
  events: { 'click span a': 'anchorEventHandler' },
  anchorEventHandler : function(event) {
    this; // will reference your instance of `MyView`
    event.target; // will reference the DOM element the action took place on. This is `a` in this example.
    event.currentTarget; // will reference `this.el` which is the root element that all events are bound to.
  }
});</code></pre>

<h4 id="layoutView" class="spacer">layoutView</h4>

<p>The <code>layoutView</code> is an instance of a special view that contains your site's header, footer, etc. The layout is like a .NET master page. This makes routing easy since you don't need an intermediate step to render the layout. Calling <code>render()</code> on the view will automatically call <code>render()</code> on the layout. The view uses the layout's <code>contentPlaceholderId</code> to get the content placeholder element. Once the views are done rendering <code>view.outerEl</code> will contain both the view and the layout. Here's an example view and layout view.</p>

<pre class="prettyprint"><code>var LayoutView = Nex.View.extend({
  template: Handlebars.compile('&lt;header&gt;Header&lt;/header&gt;&lt;div id="content"&gt;&lt;/div&gt;'),
  contentPlaceholderId: 'content'
});

var MyView = Nex.View.extend({
  template: Handlebars.compile('MyView HTML'),
  layoutView: new LayoutView()
});

new MyView().render().outerEl;

// The outerEl HTML will be
'&lt;header&gt;Header&lt;/header&gt;&lt;div id="content"&gt;&lt;div&gt;MyView HTML&lt;/div&gt;&lt;/div&gt;'</code></pre>

<h4 id="outerEl" class="spacer">outerEl</h4>

<p>The view's or <code>layoutView</code>'s outer most DOM element. If you specify a <code>layoutView</code> then <code>view.outerEl</code> will refer to the <code>layoutView.el</code>. When you attach a view to the DOM you should use <code>outerEl</code> in case it has a layout view. You should attach your view's to the document like this <code>document.querySelector('body').appendChild(new MyView().render().outerEl)</code>. Then if <code>MyView</code> has set <code>layoutView: new LayoutView()</code> it will be <code>LayoutView.el</code> that is attached to the DOM.</p>

<h4 id="contentPlaceholderId" class="spacer">contentPlaceholderId</h4>

<p>If a view is going to be used as a <code>layoutView</code> it needs to have a content-placeholder element in its HTML and set <code>view.contentPlaceholderId</code>. This is the ID of the content-placeholder element in the HTML. When you call <code>render()</code> on the child view it will automatically call <code>render()</code> on the layout view and use the <code>layoutView.contentPlaceholderId</code> to attach the child view to the layout view.</p>

<h4 id="remove" class="spacer">remove()</h4>

<p>Removes <code>view.el</code> from the DOM.</p>

<h4 id="initialize" class="spacer">initialize</h4>

<p>You can use the initialize method to add custom logic when creating a new instance of your view. In this example the <code>view.model.name</code> is passed in as an argument in the constructor.</p>

<pre class="prettyprint"><code>var MyView = Nex.View.extend({
  template: Handlebars.compile('&lt;div&gt;Hello \{{model.name}}!&lt;/div&gt;'),

  model: {},

  initialize: function(name) {
    this.model.name = name;
  },

  render: function render() {
    this.el.innerHTML = this.template({model: this.model});.
    return this;
  }
});

var myView = new MyView("Nex");
myView.render();

document.querySelector('body').appendChild(myView.outerEl); // Will display "Hello Nex!"</code></pre>

<p>The <code>initialize()</code> method is the last step before the instance is returned so everything else is set up at this point.</p>

<h4 id="tagName" class="spacer">tagName</h4>

<p>The type of DOM element - div, span, section, header, footer, etc. It defaults to a <code>div</code>.</p>

<h4 id="id" class="spacer">id</h4>

<p>The ID of the view's DOM element.</p>

<h4 id="className" class="spacer">className</h4>

<p>The class name(s) of the view's DOM element.</p>

<h4 id="dispatchMockEvent" class="spacer">dispatchMockEvent(mockEvent)</h4>

<p>Triggers a mock event for integration testing event handlers. If you just want to unit test your event handlers you can call the functions directly with a mock object. The benefit of dispatching an event is that it might trigger multiple event handlers.</p>

<p>The <code>mockEvent</code> must contain a <code>type</code> and <code>target</code>. The <code>type</code> is a click, keypress, etc. The <code>target</code> is the DOM element you're performing the action on. You can add any other properties your event handlers expect. Here's an example test that verifies that entering a new item and hitting enter saves the item to the view's model.</p>

<pre class="prettyprint"><code>var myView = new MyView();
myView.render();

var textInput = myView.el.querySelector('input.new');
textInput.value = 'my first item!';
myView.dispatchMockEvent({
  type: 'keypress',
  target: textInput,
  keyCode: 13
});

expect(myView.model.items.length).toEqual(1);
expect(myView.model.items[0].title).toEqual('my first item!');</code></pre>
