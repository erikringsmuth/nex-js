<h2>API</h2>

<h4 id="extend">Example template</h4>

<p>This is your components's HTML. Choose any template engine! Handlebars is just an example.</p>

<pre class="prettyprint"><code>&lt;!-- myTemplate.html --&gt;
&lt;div&gt;Hello \{{model.name}}!&lt;/div&gt;

&lt;!-- on-eventtype attributes call the event handler and are scoped to this component --&gt;
&lt;input type="text" placeholder="Enter your name" on-keypress="updateNameOnEnter"&gt;

&lt;!-- This is a placeholder for the Todo App component --&gt;
&lt;component name="todo-app"&gt;&lt;/component&gt;</code></pre>

<h4 id="extend" class="spacer">Nex.defineComponent(componentName, componentProperties)</h4>

<p>Define a new component.</p>

<pre class="prettyprint"><code>var MyComponent = Nex.defineComponent('my-component', {
  // The component's HTML template
  template: Handlebars.compile(myTemplate),

  // The model gets passed to the template
  model: { name: 'Nex' },

  // The layout contains your site's header, footer, etc.
  layout: Layout,

  // This event handler gets called when a keypress event is triggered on the input
  updateNameOnEnter: function(event) {
    if (event.keyCode === 13) {
      this.model.name = event.target.value;
      this.render();
    }
  },

  // Register the components you want to use. TodoApp defines the 'todo-app' component.
  components: [TodoApp]
});</code></pre>

<p>Create an instance of your component, render it, and attach it to the document.</p>

<pre class="prettyprint"><code>new MyComponent().attachTo('body');</code></pre>

<p>This will create this HTML.</p>

<pre class="prettyprint"><code>&lt;component name="my-component"&gt;
  &lt;div&gt;Hello \{{model.name}}!&lt;/div&gt;
  &lt;input type="text" placeholder="Enter your name" on-keypress="updateNameOnEnter"&gt;
  &lt;component name="todo-app"&gt;
    &lt;!-- The Todo MVC app will be attached here --&gt;
  &lt;/component&gt;
&lt;/component&gt;</code></pre>

<p>Every component is a DOM element which has a few nice features. The DOM element exists as soon as you create an instance of the component. It's fully rendered before it's attached to the document. Delegate events are attached to the root <code>&lt;component&gt;</code> element so they don't need to be re-bound every time you render the component.</p>

<p>To access DOM elements within the component you should scope your selectors using <code>component.querySelector()</code> and <code>component.querySelectorAll()</code>. This allows you to access the component's elements before attaching the component to the document. This makes unit testing much easier. It also keeps the selectors scoped to your component so you don't accidentally select an element outside of your component.</p>

<h4 id="events" class="spacer">Events</h4>

<p>Events are defined in the template using hyphenated <code>on-eventtype</code> attributes.</p>

<pre class="prettyprint"><code>&lt;input type="text" on-keypress="updateNameOnEnter"&gt;</code></pre>

<p>This differs from regular JavaScript event handlers that are not hyphenated. This will call the global <code>window.updateNameOnEnter()</code>.</p>

<pre class="prettyprint"><code>&lt;input type="text" onkeypress="updateNameOnEnter()"&gt;</code></pre>

<p>Nex events are scoped to the current component. The <code>on-keypress="updateNameOnEnter"</code> attribute tells the component to call the <code>updateNameOnEnter(event)</code> event handler.</p>

<pre class="prettyprint"><code>var MyComponent = Nex.defineComponent('my-component', {
  template: Handlebars.compile('&lt;input type="text" on-keypress="updateNameOnEnter"&gt;'),

  updateNameOnEnter: function(event) {
    // 13 is the enter key
    if (event.keyCode === 13) {
      this.model.name = event.target.value;
      this.render();
    }
  }
});</code></pre>

<p>In the event handler <code>this</code> will reference the component which is also the DOM element. <code>event.target</code> will reference the element the event was triggered on which is the <code>input</code> in this example.</p>

<h4 id="properties" class="spacer">Component Properties</h4>

<p>Component have these properties in addition to the standard DOM element properties.</p>

<ul>
  <li><code class="pln">component.template()</code> - generates the component's HTML</li>
  <li><code>component.model</code> - the model that gets passed to the template</li>
  <li><code>component.layout</code> - the layout contains your site's layout (header, footer, etc.)</li>
  <li><code>component.outerEl</code> - the <code>component</code>'s or <code>layout</code>'s outer most DOM element</li>
  <li><code>component.components</code> - sub-components or widgets that are automatically created and attached to this component</li>
  <li><code>component.render()</code> - renders the component which populates it with the template HTML</li>
  <li><code>component.html(htmlString)</code> - replaces the contents of the component with the HTML string</li>
  <li><code>component.attachTo(selector|element)</code> - attaches <code>component.outerEl</code> to the element</li>
  <li><code>component.ready()</code> - a hook to add additional logic when creating an instance of the component</li>
  <li><code>component.remove()</code> - remove the component from the DOM</li>
  <li><code>component.tagName</code> - the type of DOM element</li>
  <li><code>component.id</code> - the ID of the component's DOM element</li>
  <li><code>component.className</code> - the class name(s) of the component's DOM element</li>
  <li><code>component.autoRender</code> - defaults to <code>true</code>, set to <code>false</code> to manually trigger the first render</li>
  <li><code>component.registerComponent(Component, componentName)</code> - used to register and attach a component if the view has already been rendered</li>
  <li><code>component.dispatchEvent(event)</code> - dispatches a delegate event to the correct event handler</li>
</ul>

<h4 id="template" class="spacer">template()</h4>

<p>The template generates your component's HTML. You can use your choice of templating engines. Typically you would compile your template and set it on the template property.</p>

<pre class="prettyprint"><code>var MyComponent = Nex.defineComponent('my-component', {
  template: Handlebars.compile('&lt;div&gt;Hello \{{model.name}}!&lt;/div&gt;'),

  model: {name: 'Nex'},

  // The default render method processes the template and attaches it to the component's DOM element
  render: function render() {
    this.html(this.template(this));
    return this;
  }
});</code></pre>

<p>The compile step creates a function that takes in a model and returns an HTML string. The <code>render()</code> method passes the component to the compiled template then takes the resulting HTML and attaches it to the component.</p>

<h4 id="model" class="spacer">model</h4>

<p>The model contains your component's data. It can be an object or a constructor function. For example, if your model is <code>{name: 'Nex'}</code> it will be passed straight to the template. If your model is a constructor function like <code>function MyModel() {this.name = 'Nex'; this.time = new Date();}</code> it will be called with <code>new component.model()</code> before being passed to the template. This allows for variables to be evaluated at render time. This is useful when you need access to a closure variable that changes often.</p>

<h4 id="layout" class="spacer">layout</h4>

<p>The <code>layout</code> is a constructor or instance of a special component that contains your site's header, footer, etc. The layout is like a .NET master page or Razor layout. This makes routing easy since you don't need an intermediate step to render the layout. Calling <code>render()</code> on the component will automatically call <code>render()</code> on the layout. The component is attached to the layout using the layout's <code>&lt;component name="content-placeholder"&gt;&lt;/component&gt;</code> element. Once the components are done rendering <code>component.outerEl</code> will contain both the component and the layout. Here's an example component and layout component.</p>

<pre class="prettyprint"><code>var Layout = Nex.defineComponent('layout', {
  template: Handlebars.compile('&lt;header&gt;Header&lt;/header&gt;&lt;component name="content-placeholder"&gt;&lt;/component&gt;')
});

var HomePage = Nex.defineComponent('home-page', {
  template: Handlebars.compile('Home page HTML'),
  layout: Layout
});

new HomePage().attachTo('body');</code></pre>

The <code>body</code> HTML will be.
<pre class="prettyprint"><code>&lt;component name="layout"&gt;
  &lt;header&gt;Header&lt;/header&gt;
  &lt;component name="home-page"&gt;
    Home page HTML
  &lt;/component&gt;
&lt;/component&gt;</code></pre>

<h4 id="outerEl" class="spacer">outerEl</h4>

<p>The component's or <code>layout</code>'s outer most DOM element. If you specify a <code>layout</code> then <code>component.outerEl</code> will refer to the <code>layout</code> element. When you attach a component to the DOM you should use <code>outerEl</code>. Calling <code>component.attachTo('body')</code> will attach <code>component.outerEl</code> to the body.</p>

<h4 id="components" class="spacer">components</h4>

<p>These are sub-components that are automatically created and attached to this component. When an instance of this component is created it creates instances of the components and attaches them to their component elements.</p>

<pre class="prettyprint"><code>var MyComponent = Nex.defineComponent('my-component', {
  template: Handlebars.compile('I\'m a component!')
});

var HomePage = Nex.defineComponent('home-page', {
  template: Handlebars.compile('&lt;div&gt;Example component below.&lt;/div&gt;&lt;component name="my-component"&gt;&lt;/component&gt;'),
  components: [MyComponent] // Register the component types used by the template
});</code></pre>

An instance of <code>HomePage</code> will have this HTML.
<pre class="prettyprint"><code>&lt;component id="home-page"&gt;
  &lt;div&gt;Example component below.&lt;/div&gt;
  &lt;component id="my-component"&gt;
    I'm a component!
  &lt;/component&gt;
&lt;/component&gt;</code></pre>

<p>The cool thing about components is if you re-render this component it doesn't have to re-render it's sub-components. This component already has references to the rendered sub-components so it just attaches them again when this component finishes re-rendering. The same thing goes for re-rendering a layout. Underneath it takes the <code>&lt;component name="content-placeholder"&gt;&lt;/component&gt;</code> and attaches the content component to it.</p>

<h4 id="render" class="spacer">render()</h4>

<p>Render populates the contents of this component with the template HTML. This is called when you create a new instance of a component. When your model changes you call <code>render()</code> to update the component. Every component has a default <code>render()</code> method that looks similar to this.</p>

<pre class="prettyprint"><code>function render() {
  this.html(this.template(this));
  return this;
}</code></pre>

<p>You can override this to add your own functionality. <code>render()</code> will also handle rendering the <code>layout</code> if it has one. Overriding <code>component.render()</code> will still render the <code>layout</code> but will let you change how the current component is rendered.</p>

<h4 id="html" class="spacer">html(htmlString)</h4>

<p>Converts the HTML string to DOM elements and replaces the contents of the component. This is like setting <code>component.innerHTML</code> but works better in IE8. This is used by the default <code>render()</code> method.</p>

<h4 id="attachTo" class="spacer">attachTo(selector|element)</h4>

<p>Attaches <code>component.outerEl</code> to the element. This clears the contents of the element then appends the component.</p>

<h4 id="ready" class="spacer">ready</h4>

<p>You can use the <code>ready()</code> method to add custom logic when creating a new instance of your component. In this example the <code>component.model.name</code> is passed in as an argument in the constructor.</p>

<pre class="prettyprint"><code>var MyComponent = Nex.defineComponent('my-component', {
  template: Handlebars.compile('Hello \{{model.name}}!'),
  model: {},
  ready: function(name) {
    this.model.name = name;
  }
});

new MyComponent('Nex').attachTo('body'); // Will display "Hello Nex!"</code></pre>

<p>The <code>ready()</code> method is the last step before the component is rendered so everything else is set up at this point.</p>

<h4 id="remove" class="spacer">remove()</h4>

<p>Removes the component from the DOM.</p>

<h4 id="tagName" class="spacer">tagName</h4>

<p>The type of DOM element - component, div, span, section, header, footer, etc. It defaults to a <code>component</code>.</p>

<h4 id="id" class="spacer">id</h4>

<p>The ID of the component's DOM element.</p>

<h4 id="className" class="spacer">className</h4>

<p>The class name(s) of the component's DOM element.</p>

<h4 id="autoRender" class="spacer">autoRender</h4>

<p>Defaults to <code>true</code>, set to <code>false</code> to manually trigger the first render.</p>

<h4 id="dispatchMockEvent" class="spacer">dispatchEvent(event)</h4>

<p>Dispatches a delegate event to the correct event handler. You can also call this with a mock event for unit testing. Here's an example test.</p>

<pre class="prettyprint"><code>// Arrange
var myComponent = new MyComponent();

// Act
var input = myComponent.querySelector('input');
input.value = 'my first item!';
myComponent.dispatchEvent({
  type: 'keypress',
  target: input,
  keyCode: 13
});

// Assert
expect(myComponent.model.items.length).toEqual(1);
expect(myComponent.model.items[0].title).toEqual('my first item!');</code></pre>
